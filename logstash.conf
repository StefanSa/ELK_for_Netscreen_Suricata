input	{
		file {
			path => ["/data/log/*.log"]
			sincedb_path => "/var/log/logstash/since.db"
			start_position => "beginning"
			type => "syslog"
			tags => [ "netsyslog" ]
			}
}  #end input block

filter	{

		if [type] == "syslog"	{
			grok	{
				#strips timestamp and host off of the front of the syslog message leaving the raw message generated by the syslog client and saves it as "raw_message"
				patterns_dir => "/usr/local/etc/logstash/patterns"
				match => [ "message", "%{TIMESTAMP_ISO8601:@timestamp} %{HOST:syslog_host} %{GREEDYDATA:raw_message}" ]
					}
				}

		if "netsyslog" in [tags]		{
			if "NetScreen" in [raw_message]	{
					mutate	{
						add_tag => [ "NetScreen_log", "firewall" ]
						}
					}
			if "event_type" in [raw_message]	{
					mutate {
						add_tag => [ "suricata_log", "ips" ]
						}
					}
			if "firewall" not in [tags]	{
					mutate {
						add_tag => [ "generic_log" ]
						}
					}
			}

		if "NetScreen_log" in [tags]	{
			grok	{
				patterns_dir => "/usr/local/etc/logstash/patterns"
				match => [
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_traffic_00257_01}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_traffic_00257_02}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_traffic_00257_03}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_attacks_00005_00006}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_attacks_00007}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_attacks_00004}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_attacks_00008_00009_00010_00012_00016}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_attacks_00011_00017}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_attacks_00032_00033_00412_00413_00414_00415_00430_00431_00432_00433_00434_00437_00438_00439_00440}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_attacks_00435_00436_00441}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_attacks_00443}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_dhcp_00527_01}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_dhcp_00527_02}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_dhcp_00527_03}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_dhcp_00527_04}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ntp_00531_01}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ntp_00531_02}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ntp_00531_03}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ntp_00531_04}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ntp_00531_05}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ntp_00531_06}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ntp_00531_07}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ike_00536_01}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ike_00536_02}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ike_00536_03}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ike_00536_04}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ike_00536_05}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ike_00536_06}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ike_00536_07}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ike_00536_08}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ike_00536_09}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ike_00536_10}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ike_00536_11}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ike_00536_12}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ike_00536_13}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ike_00536_14}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ike_00536_15}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ike_00536_16}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ike_00536_17}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ike_00536_18}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ike_00536_19}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ike_00536_20}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ike_00536_21}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ike_00536_22}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ike_00536_23}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ike_00536_24}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ike_00536_25}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ike_00536_26}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ike_00536_27}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ike_00536_28}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ike_00536_29}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ike_00536_30}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ike_00536_31}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ike_00536_32}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ike_00042}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ike_00026_01}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ospf_00541_01}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ospf_00541_02}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ospf_00541_03}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ospf_00541_04}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ospf_00541_05}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ospf_00541_06}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ospf_00541_07}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ospf_00541_08}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_vpn_00040_00041}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_vpn_00536_01}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_vpn_00536_02}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_flow_00026_01}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_flow_00026_02}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_admin_00518_01}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_admin_00518_02}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_admin_00519_01}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_system_00625}",
					"raw_message", "%{NETSCREEN_TAGGED_SYSLOG} %{NETSCREENFW_ssl_00519_01}"
				]
			}

		if !("_grokparsefailure" in [tags])	{
			mutate	{
				replace => [ "message", "%{raw_message}" ]
				remove_field => [ "raw_message", "syslog_hostname", "syslog_timestamp", "host" ]
				}
			}

		} else if "suricata_log" in [tags]	{
			grok	{
				patterns_dir => "/usr/local/etc/logstash/patterns"
				match => [
					"raw_message", "%{SURICATA_TAGGED_SYSLOG} %{GREEDYDATA:suricata_message}"
				]
			}

		json	{
			source => "suricata_message"
			}

 		mutate {
			rename => [ "dest_ip","dst_ip" ]
			rename => [ "dest_port","dst_port" ]
			rename => [ "srcip","src_ip" ]
			rename => [ "sp","src_port" ]
			rename => [ "dstip","dst_ip" ]
			rename => [ "dp","dst_port" ]
			}
			
		date {
			match => [ "timestamp", "ISO8601"  ]
			}

		# Add the "inbox" tag to all incoming alerts.
		if [event_type] == "alert" {
			mutate	{
				add_tag => ["inbox"]
				}
			}

			if !("_grokparsefailure" in [tags])	{
		mutate {
			remove_field => [ "suricata_message", "raw_message", "@source", "timestamp", "gmtoffset", "time", "host", "path" ]
				replace => [ "message", "%{suricata_message}" ]
				}
			}

		} else {
		#apply actions to logs that don't match any particular type of log
	}

	#Geolocate logs that have SourceAddress and if that SourceAddress is a non-RFC1918 address or APIPA address
	if [dst_ip] !~ "(^127\.0\.0\.1)|(^10\.)|(^172\.1[6-9]\.)|(^172\.2[0-9]\.)|(^172\.3[0-1]\.)|(^192\.168\.)" {
		geoip	{
			source => "dst_ip"
			database    => "/usr/local/share/GeoIP/GeoLiteCity.dat"
			}
			#Delete 0,0 in DestinationGeo.location if equal to 0,0
			if ([geoip.location] and [geoip.location] =~ "0,0") {
				mutate	{
					replace => [ "geoip.location.location", "" ]
					}
			}
		}

	#Geolocate logs that have SourceAddress and if that SourceAddress is a non-RFC1918 address or APIPA address
	if [src_ip] !~ "(^127\.0\.0\.1)|(^10\.)|(^172\.1[6-9]\.)|(^172\.2[0-9]\.)|(^172\.3[0-1]\.)|(^192\.168\.)" {
		geoip	{
			source => "src_ip"
			database    => "/usr/local/share/GeoIP/GeoLiteCity.dat"
			}
			#Delete 0,0 in DestinationGeo.location if equal to 0,0
			if ([geoip.location] and [geoip.location] =~ "0,0") {
				mutate	{
					replace => [ "geoip.location.location", "" ]
					}
			}
		}

	#Geolocate logs that have SourceAddress and if that SourceAddress is a non-RFC1918 address or APIPA address
	if [src_vpnclient_ip] !~ "(^127\.0\.0\.1)|(^10\.)|(^172\.1[6-9]\.)|(^172\.2[0-9]\.)|(^172\.3[0-1]\.)|(^192\.168\.)|(^217\.6\.34\.([1-9]|[1-9][0-9]|1([0-1][0-9]|2[0-7])))|(^213\.166\.51\.(6[6-9]|7[0-8]))" {
		geoip	{
			source => "src_vpnclient_ip"
			database    => "/usr/local/share/GeoIP/GeoLiteCity.dat"
			}
			#Delete 0,0 in DestinationGeo.location if equal to 0,0
			if ([geoip.location] and [geoip.location] =~ "0,0") {
				mutate	{
					replace => [ "geoip.location.location", "" ]
					}
			}
		}

	#Takes the 4-tuple of source address, destination address, destination port, and protocol and does a SHA1 hash to fingerprint the flow.  This is a useful
	#way to be able to do top N terms queries on flows, not just on one field.
	if "firewall" in [tags] and [src_ip] and [dst_ip]	{
		fingerprint	{
			concatenate_sources => true
			method => "SHA1"
			key => "logstash"
			source => [ "src_ip", "dst_ip", "dst_port", "proto" ]
			}
		}

	#Takes the 4-tuple of source address, destination address, destination port, and protocol and does a SHA1 hash to fingerprint the flow.  This is a useful
	#way to be able to do top N terms queries on flows, not just on one field.	
	if "ips" in [tags] and [src_ip] and [dst_ip]	{
		fingerprint	{
			concatenate_sources => true
			method => "SHA1"
			key => "logstash"
			source => [ "src_ip", "dst_ip", "dst_port", "proto" ]
			}
		}

} #end filter block


output {
#    stdout { codec => "rubydebug" }
#    if "_grokparsefailure" in [tags] {
#    file {
#        path => "/data/log/netscreen-fail-%{+YYYY-MM-dd}.log"
#        }
#    }
#    else {
#    file {
#        path => "/data/log/netscreen-%{+YYYY-MM-dd}.log"
#        }
#   }
	stdout { codec => rubydebug }
	if "_grokparsefailure" in [tags]	{
		file {
			path => "/var/log/logstash/grokparsefailure-%{+YYYY-MM-dd}.txt"
			}
		}
	else	{
		elasticsearch {
			cluster => "elasticsearch"
			host => "192.168.1.67"
			protocol => "http"
			template => "/usr/local/etc/logstash/elasticsearch-template_02.json"
			template_overwrite => true
			}
		}
} #end output block
